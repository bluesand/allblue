#é›†åˆç±»å‹

##æ•°ç»„

###æ•°ç»„æ„é€ 
```swift
// shoppingList å·²ç»è¢«æ„é€ å¹¶ä¸”æ‹¥æœ‰ä¸¤ä¸ªåˆå§‹é¡¹ã€‚
var shoppingList: [String] = ["Eggs", "Milk"]

// æˆ–
var shoppingList = ["Eggs", "Milk"]

```

###è®¿é—®å’Œä¿®æ”¹æ•°ç»„
```swift
// è¾“å‡º"The shopping list contains 2 items."ï¼ˆè¿™ä¸ªæ•°ç»„æœ‰2ä¸ªé¡¹ï¼‰
println("The shopping list contains \(shoppingList.count) items.")

// æ‰“å° "The shopping list is not empty."ï¼ˆshoppinglistä¸æ˜¯ç©ºçš„ï¼‰
if shoppingList.isEmpty {
    println("The shopping list is empty.")
} else {
    println("The shopping list is not empty.")
}

// shoppingList ç°åœ¨æœ‰3ä¸ªæ•°æ®é¡¹ï¼Œæœ‰äººåœ¨æ‘Šç…é¥¼
shoppingList.append("Flour")

shoppingList += ["Baking Powder"]
// shoppingList ç°åœ¨æœ‰å››é¡¹äº†
shoppingList += ["Chocolate Spread","Cheese","Butter"]
// shoppingList ç°åœ¨æœ‰ä¸ƒé¡¹äº†

// ç¬¬ä¸€é¡¹æ˜¯ "Eggs"
var firstItem = shoppingList[0]

// å…¶ä¸­çš„ç¬¬ä¸€é¡¹ç°åœ¨æ˜¯ "Six eggs" è€Œä¸æ˜¯ "Eggs"
shoppingList[0] = "Six eggs"

// shoppingList ç°åœ¨æœ‰å…­é¡¹
shoppingList[4...6] = ["Bananas", "Apples"]

shoppingList.insert("Maple Syrup", atIndex: 0)
// shoppingList ç°åœ¨æœ‰7é¡¹
// "Maple Syrup" ç°åœ¨æ˜¯è¿™ä¸ªåˆ—è¡¨ä¸­çš„ç¬¬ä¸€é¡¹

let mapleSyrup = shoppingList.removeAtIndex(0)
// ç´¢å¼•å€¼ä¸º0çš„æ•°æ®é¡¹è¢«ç§»é™¤
// shoppingList ç°åœ¨åªæœ‰6é¡¹ï¼Œè€Œä¸”ä¸åŒ…æ‹¬Maple Syrup
// mapleSyrupå¸¸é‡çš„å€¼ç­‰äºè¢«ç§»é™¤æ•°æ®é¡¹çš„å€¼ "Maple Syrup"

// firstItem ç°åœ¨ç­‰äº "Six eggs"
firstItem = shoppingList[0]

let apples = shoppingList.removeLast()
// æ•°ç»„çš„æœ€åä¸€é¡¹è¢«ç§»é™¤äº†
// shoppingListç°åœ¨åªæœ‰5é¡¹ï¼Œä¸åŒ…æ‹¬cheese
// apples å¸¸é‡çš„å€¼ç°åœ¨ç­‰äº"Apples" å­—ç¬¦ä¸²
```

###æ•°ç»„çš„éå†
```swift
for item in shoppingList {
    println(item)
}
// Six eggs
// Milk
// Flour
// Baking Powder
// Bananas
```

###ç‰¹å®šç±»å‹æ„é€ 
```swift
var someInts = [Int]()
println("someInts is of type [Int] with \(someInts.count) itemsã€‚")
// æ‰“å° "someInts is of type [Int] with 0 itemsã€‚"ï¼ˆsomeIntsæ˜¯0æ•°æ®é¡¹çš„Int[]æ•°ç»„ï¼‰

omeInts.append(3)
// someInts ç°åœ¨åŒ…å«ä¸€ä¸ªINTå€¼
someInts = []
// someInts ç°åœ¨æ˜¯ç©ºæ•°ç»„ï¼Œä½†æ˜¯ä»ç„¶æ˜¯[Int]ç±»å‹çš„ã€‚

var threeDoubles = [Double](count: 3, repeatedValue:0.0)
// threeDoubles æ˜¯ä¸€ç§ [Double]æ•°ç»„, ç­‰äº [0.0, 0.0, 0.0]

var anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)
// anotherThreeDoubles is inferred as [Double], and equals [2.5, 2.5, 2.5]

var sixDoubles = threeDoubles + anotherThreeDoubles
// sixDoubles è¢«æ¨æ–­ä¸º [Double], ç­‰äº [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]
```

##é›†åˆ
###æ„é€ Set
```swift
var letters = Set<Character>()
println("letters is of type Set<Character> with \(letters.count) items.")
// æ‰“å° "letters is of type Set<Character> with 0 items."

// lettersç°åœ¨å«æœ‰1ä¸ªCharacterç±»å‹çš„å€¼
letters.insert("a")

// lettersç°åœ¨æ˜¯ä¸€ä¸ªç©ºçš„Set, ä½†æ˜¯å®ƒä¾ç„¶æ˜¯Set<Character>ç±»å‹
letters = []

// favoriteGenresè¢«æ„é€ æˆå«æœ‰ä¸‰ä¸ªåˆå§‹å€¼çš„é›†åˆ
var favoriteGenres: Set<String> = ["Rock", "Classical", "Hip hop"]

//å¯æ¨æ–­ç±»å‹ä¸º Set<String>
var favoriteGenres: Set = ["Rock", "Classical", "Hip hop"]
```

###è®¿é—®å’Œä¿®æ”¹Set
```swift
// æ‰“å° ""I have 3 favorite music genres.""
println("I have \(favoriteGenres.count) favorite music genres.")

if favoriteGenres.isEmpty {
    println("As far as music goes, I'm not picky.")
} else {
    println("I have particular music preferences.")
}
// æ‰“å° "I have particular music preferences."

// æ·»åŠ ï¼ŒfavoriteGenres ç°åœ¨åŒ…å«4ä¸ªå…ƒç´ 
favoriteGenres.insert("Jazz")

// åˆ é™¤ï¼Œ å¦‚æœè¯¥å€¼æ˜¯è¯¥Setçš„ä¸€ä¸ªå…ƒç´ åˆ™åˆ é™¤è¯¥å…ƒç´ å¹¶ä¸”è¿”å›è¢«åˆ é™¤çš„å…ƒç´ å€¼ï¼Œå¦è®¤å¦‚æœè¯¥Setä¸åŒ…å«è¯¥å€¼ï¼Œåˆ™è¿”å›nil
if let removedGenre = favoriteGenres.remove("Rock") {
    println("\(removedValue)? I'm over it.")
} else {
    println("I never much cared for that.")
}
// æ‰“å° "Rock? I'm over it."

//removeAll åˆ é™¤æ‰€æœ‰

//contains
if favoriteGenres.contains("Funk") {
    println("I get up on the good foot.")
} else {
    println("It's too funky in here.")
}
// æ‰“å° "It's too funky in here.

```

###éå†Set
```swift
for genre in favoriteGenres {
    println("\(value)")
}
// Classical
// Jazz
// Hip hop

// sorted
for genre in sorted(favoriteGenres) {
    println("\(genre)")
}
// prints "Classical"
// prints "Hip hop"
// prints "Jazz

```

###é›†åˆæ“ä½œ
![](image/setVennDiagram_2x.png)
```swift

/*
ä½¿ç”¨union(_:)æ–¹æ³•æ ¹æ®ä¸¤ä¸ªé›†åˆçš„å€¼åˆ›å»ºä¸€ä¸ªæ–°çš„é›†åˆã€‚
ä½¿ç”¨subtract(_:)æ–¹æ³•æ ¹æ®ä¸åœ¨è¯¥é›†åˆä¸­çš„å€¼åˆ›å»ºä¸€ä¸ªæ–°çš„é›†åˆã€‚
ä½¿ç”¨intersect(_:)æ–¹æ³•æ ¹æ®ä¸¤ä¸ªé›†åˆä¸­éƒ½åŒ…å«çš„å€¼åˆ›å»ºçš„ä¸€ä¸ªæ–°çš„é›†åˆã€‚
ä½¿ç”¨exclusiveOr(_:)æ–¹æ³•æ ¹æ®å€¼åœ¨ä¸€ä¸ªé›†åˆä¸­ä½†ä¸åœ¨ä¸¤ä¸ªé›†åˆä¸­çš„å€¼åˆ›å»ºä¸€ä¸ªæ–°çš„é›†åˆã€‚
*/

let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]
sorted(oddDigits.union(evenDigits))
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
sorted(oddDigits.intersect(evenDigits))
// []
sorted(oddDigits.subtract(singleDigitPrimeNumbers))
// [1, 9]
sorted(oddDigits.exclusiveOr(singleDigitPrimeNumbers))
// [1, 2, 9]

```

###é›†åˆæ¯”è¾ƒ
![](image/setEulerDiagram_2x.png)
```swift
/*
ä½¿ç”¨â€œæ˜¯å¦ç­‰â€è¿ç®—ç¬¦(=)æ¥åˆ¤æ–­ä¸¤ä¸ªé›†åˆæ˜¯å¦åŒ…å«ç›¸åŒçš„å€¼ã€‚
ä½¿ç”¨isSubsetOf(_:)æ–¹æ³•æ¥åˆ¤æ–­ä¸€ä¸ªé›†åˆä¸­çš„å€¼æ˜¯å¦ä¹Ÿè¢«åŒ…å«åœ¨å¦å¤–ä¸€ä¸ªé›†åˆä¸­ã€‚
ä½¿ç”¨isSupersetOf(_:)æ–¹æ³•æ¥åˆ¤æ–­ä¸€ä¸ªé›†åˆä¸­åŒ…å«çš„å€¼æ˜¯å¦ä¸€ä¸ªé›†åˆä¸­æ‰€æœ‰çš„å€¼ã€‚
ä½¿ç”¨isStrictSubsetOf(_:)æˆ–è€…isStrictSupersetOf(_:)æ–¹æ³•æ¥åˆ¤æ–­ä¸€ä¸ªé›†åˆæ˜¯å¦æ˜¯å¦å¤–ä¸€ä¸ªé›†åˆçš„å­é›†åˆæˆ–è€…çˆ¶é›†åˆå¹¶ä¸”å’Œç‰¹å®šé›†åˆä¸ç›¸ç­‰ã€‚
ä½¿ç”¨isDisjointWith(_:)æ–¹æ³•æ¥åˆ¤æ–­ä¸¤ä¸ªç»“åˆæ˜¯å¦ä¸å«æœ‰ç›¸åŒçš„å€¼ã€‚
*/

let houseAnimals: Set = ["ğŸ¶", "ğŸ±"]
let farmAnimals: Set = ["ğŸ®", "ğŸ”", "ğŸ‘", "ğŸ¶", "ğŸ±"]
let cityAnimals: Set = ["ğŸ¦", "ğŸ­"]
houseAnimals.isSubsetOf(farmAnimals)
// true
farmAnimals.isSuperSetOf(houseAnimals)
// true
farmAnimals.isDisjointWith(cityAnimals)
// true
```

###Setç±»å‹çš„å“ˆå¸Œå€¼
```swift
/*
ä¸ºäº†å­˜å‚¨åœ¨é›†åˆä¸­ï¼Œè¯¥ç±»å‹å¿…é¡»æ˜¯å¯å“ˆå¸ŒåŒ–çš„-ä¹Ÿå°±æ˜¯è¯´ï¼Œè¯¥ç±»å‹å¿…é¡»æä¾›ä¸€ä¸ªæ–¹æ³•æ¥è®¡ç®—å®ƒçš„å“ˆå¸Œå€¼ã€‚
ä¸€ä¸ªå“ˆå¸Œå€¼æ˜¯Intç±»å‹çš„ï¼Œå®ƒå’Œå…¶ä»–çš„å¯¹è±¡ç›¸åŒï¼Œå…¶è¢«ç”¨æ¥æ¯”è¾ƒç›¸ç­‰ä¸å¦ï¼Œæ¯”å¦‚a==b,å®ƒéµå¾ªçš„æ˜¯a.hashValue == b.hashValueã€‚

a==a(è‡ªåæ€§)
a==bæ„å‘³ç€b==a(å¯¹ç§°æ€§)
a==b&&b==cæ„å‘³ç€a==c(ä¼ é€’æ€§)

*/
```

##å­—å…¸

###å­—å…¸å­—é¢é‡
```swift
var airports: [String:String] = ["TYO": "Tokyo", "DUB": "Dublin"]
//æˆ–
var airports = ["TYO": "Tokyo", "DUB": "Dublin"]
```
###è¯»å–å’Œä¿®æ”¹å­—å…¸
```swift
println("The dictionary of airports contains \(airports.count) items.")
// æ‰“å° "The dictionary of airports contains 2 items."ï¼ˆè¿™ä¸ªå­—å…¸æœ‰ä¸¤ä¸ªæ•°æ®é¡¹ï¼‰

if airports.isEmpty {
    println("The airports dictionary is empty.")
} else {
    println("The airports dictionary is not empty.")
}
// æ‰“å° "The airports dictionary is not empty.(è¿™ä¸ªå­—å…¸ä¸ä¸ºç©º)"

// airports å­—å…¸ç°åœ¨æœ‰ä¸‰ä¸ªæ•°æ®é¡¹
airports["LHR"] = "London"

// "LHR"å¯¹åº”çš„å€¼ è¢«æ”¹ä¸º "London Heathrow
airports["LHR"] = "London Heathrow"


/*
updateValue(forKey:)æ–¹æ³•åœ¨è¿™ä¸ªé”®ä¸å­˜åœ¨å¯¹åº”å€¼çš„æ—¶å€™è®¾ç½®å€¼æˆ–è€…åœ¨å­˜åœ¨æ—¶æ›´æ–°å·²å­˜åœ¨çš„å€¼ã€‚
å’Œä¸Šé¢çš„ä¸‹æ ‡æ–¹æ³•ä¸ä¸€æ ·ï¼Œè¿™ä¸ªæ–¹æ³•è¿”å›æ›´æ–°å€¼ä¹‹å‰çš„åŸå€¼ã€‚è¿™æ ·æ–¹ä¾¿æˆ‘ä»¬æ£€æŸ¥æ›´æ–°æ˜¯å¦æˆåŠŸã€‚

updateValue(forKey:)å‡½æ•°ä¼šè¿”å›åŒ…å«ä¸€ä¸ªå­—å…¸å€¼ç±»å‹çš„å¯é€‰å€¼ã€‚
ä¸¾ä¾‹æ¥è¯´ï¼šå¯¹äºå­˜å‚¨Stringå€¼çš„å­—å…¸ï¼Œè¿™ä¸ªå‡½æ•°ä¼šè¿”å›ä¸€ä¸ªString?æˆ–è€…â€œå¯é€‰ Stringâ€ç±»å‹çš„å€¼ã€‚å¦‚æœå€¼å­˜åœ¨ï¼Œåˆ™è¿™ä¸ªå¯é€‰å€¼å€¼ç­‰äºè¢«æ›¿æ¢çš„å€¼ï¼Œå¦åˆ™å°†ä¼šæ˜¯nilã€‚

*/
if let oldValue = airports.updateValue("Dublin Internation", forKey: "DUB") {
    println("The old value for DUB was \(oldValue).")
}
// è¾“å‡º "The old value for DUB was Dublin."ï¼ˆDUBåŸå€¼æ˜¯dublinï¼‰


if let airportName = airports["DUB"] {
    println("The name of the airport is \(airportName).")
} else {
    println("That airport is not in the airports dictionary.")
}
// æ‰“å° "The name of the airport is Dublin Internation."

//å¯ä»¥ä½¿ç”¨ä¸‹æ ‡è¯­æ³•æ¥é€šè¿‡ç»™æŸä¸ªé”®çš„å¯¹åº”å€¼èµ‹å€¼ä¸ºnilæ¥ä»å­—å…¸é‡Œç§»é™¤ä¸€ä¸ªé”®å€¼å¯¹
airports["APL"] = "Apple Internation"
// "Apple Internation"ä¸æ˜¯çœŸçš„ APLæœºåœº, åˆ é™¤å®ƒ
airports["APL"] = nil
// APLç°åœ¨è¢«ç§»é™¤äº†

/*
removeValueForKeyæ–¹æ³•ä¹Ÿå¯ä»¥ç”¨æ¥åœ¨å­—å…¸ä¸­ç§»é™¤é”®å€¼å¯¹ã€‚
è¿™ä¸ªæ–¹æ³•åœ¨é”®å€¼å¯¹å­˜åœ¨çš„æƒ…å†µä¸‹ä¼šç§»é™¤è¯¥é”®å€¼å¯¹å¹¶ä¸”è¿”å›è¢«ç§»é™¤çš„valueæˆ–è€…åœ¨æ²¡æœ‰å€¼çš„æƒ…å†µä¸‹è¿”å›nil
*/
if let removedValue = airports.removeValueForKey("DUB") {
    println("The removed airport's name is \(removedValue).")
} else {
    println("The airports dictionary does not contain a value for DUB.")
}
// prints "The removed airport's name is Dublin International."

```

###å­—å…¸éå†
```swift
for (airportCode, airportName) in airports {
    println("\(airportCode): \(airportName)")
}
// TYO: Tokyo
// LHR: London Heathrow


for airportCode in airports.keys {
    println("Airport code: \(airportCode)")
}
// Airport code: TYO
// Airport code: LHR

for airportName in airports.values {
    println("Airport name: \(airportName)")
}
// Airport name: Tokyo
// Airport name: London Heathrow

let airportCodes = Array(airports.keys)
// airportCodes is ["TYO", "LHR"]

let airportNames = Array(airports.values)
// airportNames is ["Tokyo", "London Heathrow"]

```

###æ„é€ ç©ºå­—å…¸
```swift
var namesOfIntegers = Dictionary<Int, String>()
// namesOfIntegers æ˜¯ä¸€ä¸ªç©ºçš„ Dictionary<Int, String>

namesOfIntegers[16] = "sixteen"
// namesOfIntegers ç°åœ¨åŒ…å«ä¸€ä¸ªé”®å€¼å¯¹

//å¦‚æœä¸Šä¸‹æ–‡å·²ç»æä¾›äº†ä¿¡æ¯ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç©ºå­—å…¸å­—é¢é‡æ¥åˆ›å»ºä¸€ä¸ªç©ºå­—å…¸ï¼Œè®°ä½œ[:]
namesOfIntegers = [:]
// namesOfIntegers åˆæˆä¸ºäº†ä¸€ä¸ª Int, Stringç±»å‹çš„ç©ºå­—å…¸
```

